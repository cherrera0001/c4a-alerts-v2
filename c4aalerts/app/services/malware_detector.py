"""
Malware detection service for C4A Alerts.

Detects various types of malware including payload downloaders, droppers,
and evasion techniques based on behavioral patterns and signatures.
"""

import re
from typing import Any, Dict, List, Tuple
from dataclasses import dataclass

from c4aalerts.app.schemas.alert import (
    IOC, IOCType, AttackTechnique, MalwareFamily,
    AlertSeverity, NormalizedAlert
)
from c4aalerts.app.monitoring.alerting import alert_manager


@dataclass
class DetectionRule:
    """Detection rule for malware patterns."""
    name: str
    description: str
    pattern: str
    severity: AlertSeverity
    techniques: List[AttackTechnique]
    confidence: float
    tags: List[str]


class MalwareDetectorService:
    """Service for detecting malware patterns and behaviors."""

    def __init__(self):
        self.detection_rules = self._initialize_detection_rules()
        self.evasion_patterns = self._initialize_evasion_patterns()
        self.suspicious_commands = self._initialize_suspicious_commands()

    def _initialize_detection_rules(self) -> List[DetectionRule]:
        """Initialize detection rules for malware patterns."""
        return [
            # Payload Downloader Detection
            DetectionRule(
                name="payload_downloader_wget_curl",
                description="Detects use of wget/curl for dynamic payload download",
                pattern=r"(wget|curl)\s+.*?http[s]?://.*?\.(sh|exe|bin|elf|dll)",
                severity=AlertSeverity.HIGH,
                techniques=[AttackTechnique.T1105, AttackTechnique.T1071_001],
                confidence=0.8,
                tags=["payload_downloader", "dynamic_download"]
            ),

            # File Descriptor Redirection (exec 3<>)
            DetectionRule(
                name="file_descriptor_redirection",
                description="Detects file descriptor redirection for network communication",
                pattern=r"exec\s+\d+<>.*?/dev/tcp",
                severity=AlertSeverity.CRITICAL,
                techniques=[AttackTechnique.T1071_001, AttackTechnique.T1027],
                confidence=0.9,
                tags=["evasion", "network_communication", "file_descriptor"]
            ),

            # Architecture Detection and Conditional Execution
            DetectionRule(
                name="architecture_detection_execution",
                description="Detects architecture detection followed by conditional binary execution",
                pattern=r"uname.*?arch.*?chmod.*?\+x.*?\./",
                severity=AlertSeverity.HIGH,
                techniques=[AttackTechnique.T1059_004, AttackTechnique.T1204_002],
                confidence=0.85,
                tags=["architecture_detection", "conditional_execution"]
            ),

            # Temporary Directory Execution
            DetectionRule(
                name="temp_dir_execution",
                description="Detects execution of binaries from temporary directories",
                pattern=r"(/tmp|/var/tmp|/dev/shm)/.*?chmod.*?\+x",
                severity=AlertSeverity.HIGH,
                techniques=[AttackTechnique.T1059_004, AttackTechnique.T1036_005],
                confidence=0.8,
                tags=["temp_execution", "masquerading"]
            ),

            # RedTail Malware Specific Patterns
            DetectionRule(
                name="redtail_malware_pattern",
                description="Detects RedTail malware specific patterns",
                pattern=r"\.redtail.*?chmod.*?\+x.*?\./\.redtail",
                severity=AlertSeverity.CRITICAL,
                techniques=[AttackTechnique.T1059_004, AttackTechnique.T1204_002],
                confidence=0.95,
                tags=["redtail", "malware", "binary_execution"]
            ),

            # Noexec Mount Detection Bypass
            DetectionRule(
                name="noexec_bypass",
                description="Detects attempts to bypass noexec mount restrictions",
                pattern=r"cat.*?/proc/mounts.*?noexec.*?find.*?-perm.*?u=rwx",
                severity=AlertSeverity.HIGH,
                techniques=[AttackTechnique.T1036_005, AttackTechnique.T1027],
                confidence=0.85,
                tags=["noexec_bypass", "evasion"]
            ),

            # Multiple Download Methods
            DetectionRule(
                name="multiple_download_methods",
                description="Detects use of multiple download methods as fallback",
                pattern=r"wget.*?\|\|.*?curl.*?\|\|.*?exec.*?/dev/tcp",
                severity=AlertSeverity.HIGH,
                techniques=[AttackTechnique.T1105, AttackTechnique.T1027],
                confidence=0.9,
                tags=["multiple_download", "fallback", "evasion"]
            ),

            # Hidden File Creation
            DetectionRule(
                name="hidden_file_creation",
                description="Detects creation of hidden files for persistence",
                pattern=r"rm.*?-rf.*?\..*?mv.*?\.redtail",
                severity=AlertSeverity.MEDIUM,
                techniques=[AttackTechnique.T1036_005, AttackTechnique.T1027],
                confidence=0.7,
                tags=["hidden_files", "persistence"]
            )
        ]

    def _initialize_evasion_patterns(self) -> Dict[str, str]:
        """Initialize patterns for evasion techniques."""
        return {
            "file_descriptor_redirection": r"exec\s+\d+<>",
            "noexec_detection": r"cat.*?/proc/mounts.*?grep.*?noexec",
            "architecture_detection": r"uname.*?-mp",
            "temporary_execution": r"(/tmp|/var/tmp|/dev/shm)/.*?chmod.*?\+x",
            "hidden_file_operations": r"rm.*?-rf.*?\..*?mv.*?\.",
            "multiple_download": r"wget.*?\|\|.*?curl",
            "conditional_execution": r"if.*?then.*?chmod.*?\+x",
            "background_execution": r">/dev/null.*?2>&1",
            "file_testing": r"touch.*?\.testfile.*?dd.*?if=/dev/zero"
        }

    def _initialize_suspicious_commands(self) -> List[str]:
        """Initialize list of suspicious commands."""
        return [
            "wget", "curl", "exec", "chmod +x", "./", "sh", "bash",
            "/dev/tcp", "/dev/zero", "dd", "truncate", "uname",
            "cat /proc/mounts", "find / -type d", "whoami"
        ]

    def analyze_content(self, content: str, source: str = "unknown") -> Dict[str, Any]:
        """Analyze content for malware patterns."""
        results = {
            "detected_malware": False,
            "malware_family": MalwareFamily.UNKNOWN,
            "detection_rules": [],
            "evasion_techniques": [],
            "suspicious_commands": [],
            "confidence_score": 0.0,
            "severity": AlertSeverity.LOW,
            "attack_techniques": [],
            "recommended_actions": []
        }

        # Check detection rules
        for rule in self.detection_rules:
            if re.search(rule.pattern, content, re.IGNORECASE | re.MULTILINE):
                results["detected_malware"] = True
                results["detection_rules"].append(rule.name)
                results["attack_techniques"].extend(rule.techniques)
                results["confidence_score"] = max(results["confidence_score"], rule.confidence)

                # Update severity if higher
                if rule.severity.value > results["severity"].value:
                    results["severity"] = rule.severity

                # Identify malware family
                if "redtail" in rule.tags:
                    results["malware_family"] = MalwareFamily.REDTAIL

        # Check evasion patterns
        for technique, pattern in self.evasion_patterns.items():
            if re.search(pattern, content, re.IGNORECASE | re.MULTILINE):
                results["evasion_techniques"].append(technique)

        # Check suspicious commands
        for command in self.suspicious_commands:
            if command.lower() in content.lower():
                results["suspicious_commands"].append(command)

        # Generate recommended actions
        results["recommended_actions"] = self._generate_recommended_actions(results)

        return results

    def _generate_recommended_actions(self, analysis_results: Dict[str, Any]) -> List[str]:
        """Generate recommended actions based on analysis results."""
        actions = []

        if analysis_results["detected_malware"]:
            actions.append("ðŸš¨ ALERTA CRÃTICA: Malware detectado - Aislar sistema inmediatamente")
            actions.append("ðŸ“‹ Revisar logs del sistema para identificar punto de entrada")
            actions.append("ðŸ” Analizar procesos en ejecuciÃ³n para detectar actividad maliciosa")

        if "temp_execution" in analysis_results["evasion_techniques"]:
            actions.append("ðŸ›¡ï¸ Bloquear ejecuciÃ³n de binarios en directorios temporales (/tmp, /var/tmp, /dev/shm)")
            actions.append("ðŸ“ Configurar polÃ­ticas de ejecuciÃ³n restrictivas en directorios temporales")

        if "file_descriptor_redirection" in analysis_results["evasion_techniques"]:
            actions.append("ðŸŒ Monitorear conexiones de red sospechosas usando /dev/tcp")
            actions.append("ðŸ”’ Restringir acceso a /dev/tcp para usuarios no privilegiados")

        if "multiple_download" in analysis_results["evasion_techniques"]:
            actions.append("â¬‡ï¸ Restringir uso de wget, curl y mÃ©todos de descarga dinÃ¡mica")
            actions.append("ðŸ“Š Implementar detecciÃ³n de patrones de descarga mÃºltiple")

        if "architecture_detection" in analysis_results["evasion_techniques"]:
            actions.append("ðŸ’» Monitorear comandos de detecciÃ³n de arquitectura del sistema")
            actions.append("ðŸ” Implementar controles de ejecuciÃ³n basados en arquitectura")

        if "hidden_file_operations" in analysis_results["evasion_techniques"]:
            actions.append("ðŸ‘ï¸ Monitorear creaciÃ³n de archivos ocultos y operaciones de renombrado")
            actions.append("ðŸ“‚ Implementar detecciÃ³n de archivos con nombres sospechosos")

        if analysis_results["malware_family"] == MalwareFamily.REDTAIL:
            actions.append("ðŸŽ¯ DETECCIÃ“N ESPECÃFICA: RedTail malware - Implementar reglas especÃ­ficas")
            actions.append("ðŸ” Buscar archivos .redtail en el sistema")
            actions.append("ðŸ“‹ Revisar historial de comandos para detectar actividad previa")

        # General recommendations
        actions.append("ðŸ“Š Implementar logging detallado de comandos ejecutados")
        actions.append("ðŸ›¡ï¸ Configurar EDR (Endpoint Detection and Response) si estÃ¡ disponible")
        actions.append("ðŸ“§ Notificar al equipo de seguridad sobre el incidente")

        return actions

    def create_malware_alert(self, content: str, source: str, analysis_results: Dict[str, Any]) -> NormalizedAlert:
        """Create a normalized alert for detected malware."""
        # Extract IOCs from content
        iocs = self._extract_iocs_from_content(content)

        # Create alert
        alert = NormalizedAlert(
            uid=f"malware_{source}_{hash(content) % 1000000}",
            source=source,
            title=f"Malware Detectado: {analysis_results['malware_family'].value.upper()}",
            description=f"Se detectÃ³ actividad maliciosa en {source}. Familia: {analysis_results['malware_family'].value}",
            severity=analysis_results["severity"],
            iocs=iocs,
            tags=analysis_results["detection_rules"] + analysis_results["evasion_techniques"],
            content_hash=str(hash(content)),
            confidence=analysis_results["confidence_score"],
            malware_analysis=analysis_results,
            detection_rules=analysis_results["detection_rules"],
            recommended_actions=analysis_results["recommended_actions"]
        )

        return alert

    def _extract_iocs_from_content(self, content: str) -> List[IOC]:
        """Extract IOCs from content."""
        iocs = []

        # Extract IP addresses
        ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
        for match in re.finditer(ip_pattern, content):
            iocs.append(IOC(
                value=match.group(),
                type=IOCType.IP_ADDRESS,
                confidence=0.8,
                tags=["malware_c2", "command_and_control"]
            ))

        # Extract URLs
        url_pattern = r'https?://[^\s<>"{}|\\^`\[\]]+'
        for match in re.finditer(url_pattern, content):
            iocs.append(IOC(
                value=match.group(),
                type=IOCType.URL,
                confidence=0.7,
                tags=["malware_download", "payload_url"]
            ))

        # Extract suspicious file names
        file_pattern = r'\.(redtail|sh|exe|bin|elf|dll)\b'
        for match in re.finditer(file_pattern, content):
            iocs.append(IOC(
                value=match.group(),
                type=IOCType.MALWARE,
                confidence=0.6,
                tags=["malware_file", "suspicious_extension"]
            ))

        return iocs


# Global instance
malware_detector = MalwareDetectorService()
