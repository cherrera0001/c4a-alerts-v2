import { BaseAgent } from "./agent.base.js";
import IAClient from "../ia/ia.client.js";
import { logger } from "../../utils/logger.js";
import { createAlert } from "../alerts.service.js";
import { getAssetsForOrganization } from "../assets.service.js";
import { db } from "../../config/firebase.js";

/**
 * Agente de Triage CTI
 * Evalúa la relevancia de items CTI para activos
 * Prioriza amenazas y decide si generar alertas
 */

class TriageAgent extends BaseAgent {
  constructor(config = {}) {
    super({
      name: "TriageAgent",
      ...config,
    });

    this.iaClient = config.iaClient || new IAClient({
      enabled: !!process.env.OPENAI_API_KEY || 
               !!process.env.AZURE_OPENAI_API_KEY || 
               !!process.env.GOOGLE_AI_API_KEY,
    });

    // Umbrales de prioridad
    this.relevanceThreshold = config.relevanceThreshold || 0.6; // 60% mínimo
    this.criticalSeverityThreshold = config.criticalSeverityThreshold || 0.8; // 80% para críticos
    this.autoGenerateAlerts = config.autoGenerateAlerts !== false;
  }

  /**
   * Evalúa un item CTI y decide acciones
   * @param {Object} input - { ctiItem: {...}, organizationId: "...", assets: [...] }
   * @returns {Promise<Object>} Resultado del triage
   */
  async process(input) {
    const { ctiItem, organizationId, assets } = input;

    if (!ctiItem || !ctiItem.id) {
      throw new Error("ctiItem con id es requerido");
    }

    if (!organizationId) {
      throw new Error("organizationId es requerido");
    }

    try {
      logger.info("Realizando triage de item CTI", { 
        ctiItemId: ctiItem.id,
        organizationId 
      });

      // Obtener activos si no se proporcionaron
      let assetsToEvaluate = assets;
      if (!assetsToEvaluate || assetsToEvaluate.length === 0) {
        const assetsResult = await getAssetsForOrganization(organizationId, {
          limit: 1000,
        });
        assetsToEvaluate = assetsResult.assets || [];
      }

      const evaluations = [];
      const alertsGenerated = [];

      // Evaluar relevancia para cada activo
      for (const asset of assetsToEvaluate) {
        try {
          let relevanceAssessment = null;

          // Usar IA para evaluar relevancia si está disponible
          if (this.iaClient && this.iaClient.enabled) {
            try {
              relevanceAssessment = await this.iaClient.assessRelevanceToAsset(ctiItem, asset);
            } catch (error) {
              logger.warn("Error evaluando relevancia con IA, usando método heurístico", {
                error: error.message,
                assetId: asset.id,
              });
            }
          }

          // Método heurístico de respaldo
          if (!relevanceAssessment || relevanceAssessment.confidence < 0.5) {
            relevanceAssessment = this.heuristicRelevanceAssessment(ctiItem, asset);
          }

          evaluations.push({
            assetId: asset.id,
            assetName: asset.name,
            assessment: relevanceAssessment,
          });

          // Decidir si generar alerta
          if (this.shouldGenerateAlert(relevanceAssessment, ctiItem, asset)) {
            if (this.autoGenerateAlerts) {
              try {
                // Obtener un usuario de la organización
                const usersSnapshot = await db
                  .collection("users")
                  .where("organizationId", "==", organizationId)
                  .limit(1)
                  .get();

                if (!usersSnapshot.empty) {
                  const userId = usersSnapshot.docs[0].id;
                  const alertType = this.determineAlertType(relevanceAssessment, ctiItem);

                  const alert = await createAlert(userId, {
                    assetId: asset.id,
                    type: alertType,
                    title: `[CTI] ${ctiItem.title}`,
                    description: this.generateAlertDescription(ctiItem, asset, relevanceAssessment),
                    source: "CTI_FEED",
                    cveIds: ctiItem.cveIds || [],
                    tactics: ctiItem.enrichmentData?.mappedTactics || [],
                    metadata: {
                      ctiItemId: ctiItem.id,
                      ctiSource: ctiItem.source,
                      relevanceScore: relevanceAssessment.relevanceScore,
                      relevanceConfidence: relevanceAssessment.confidence,
                      autoGenerated: true,
                      triageAgent: this.name,
                    },
                  });

                  alertsGenerated.push(alert);
                  logger.info("Alerta generada por agente de triage", {
                    alertId: alert.id,
                    assetId: asset.id,
                    ctiItemId: ctiItem.id,
                  });
                }
              } catch (error) {
                logger.error("Error generando alerta en triage", {
                  error: error.message,
                  assetId: asset.id,
                  ctiItemId: ctiItem.id,
                });
              }
            }
          }
        } catch (error) {
          logger.error("Error evaluando activo en triage", {
            error: error.message,
            assetId: asset.id,
            ctiItemId: ctiItem.id,
          });
        }
      }

      // Calcular prioridad general
      const priority = this.calculateOverallPriority(evaluations, ctiItem);

      const result = {
        ctiItemId: ctiItem.id,
        organizationId,
        priority,
        assetsEvaluated: assetsToEvaluate.length,
        relevantAssets: evaluations.filter(e => e.assessment.relevant).length,
        evaluations,
        alertsGenerated: alertsGenerated.length,
        alertIds: alertsGenerated.map(a => a.id),
        timestamp: new Date(),
      };

      logger.info("Triage completado", {
        ctiItemId: ctiItem.id,
        priority,
        relevantAssets: result.relevantAssets,
        alertsGenerated: result.alertsGenerated,
      });

      return result;
    } catch (error) {
      logger.error("Error en proceso de triage", {
        error: error.message,
        ctiItemId: ctiItem?.id,
        organizationId,
      });
      throw error;
    }
  }

  /**
   * Evaluación heurística de relevancia (sin IA)
   * @param {Object} ctiItem - Item CTI
   * @param {Object} asset - Activo
   * @returns {Object} Evaluación de relevancia
   */
  heuristicRelevanceAssessment(ctiItem, asset) {
    let relevanceScore = 0;
    const reasons = [];

    // Si no hay CVEs, baja relevancia
    if (!ctiItem.cveIds || ctiItem.cveIds.length === 0) {
      return {
        relevant: false,
        confidence: 0.5,
        relevanceScore: 0.2,
        reasons: ["No hay CVEs asociados"],
        riskLevel: "none",
      };
    }

    // Buscar menciones de tecnologías en tags del activo
    const assetTags = (asset.tags || []).join(" ").toLowerCase();
    const assetName = (asset.name || "").toLowerCase();
    const ctiText = ((ctiItem.title || "") + " " + (ctiItem.summary || "")).toLowerCase();

    // Patrones de tecnologías comunes
    const techPatterns = {
      "apache": /apache|httpd/i,
      "nginx": /nginx/i,
      "nodejs": /node[.\s]?js|node\.js/i,
      "react": /react/i,
      "docker": /docker/i,
      "kubernetes": /k8s|kubernetes/i,
    };

    let matches = 0;
    for (const [tech, pattern] of Object.entries(techPatterns)) {
      if ((pattern.test(assetTags) || pattern.test(assetName)) && pattern.test(ctiText)) {
        matches++;
        reasons.push(`Coincidencia de tecnología: ${tech}`);
      }
    }

    if (matches > 0) {
      relevanceScore = Math.min(0.5 + matches * 0.15, 1.0);
    }

    // Ajustar por severidad
    if (ctiItem.severity === "CRITICAL") {
      relevanceScore = Math.min(relevanceScore + 0.3, 1.0);
      reasons.push("Severidad crítica");
    } else if (ctiItem.severity === "HIGH") {
      relevanceScore = Math.min(relevanceScore + 0.2, 1.0);
      reasons.push("Severidad alta");
    }

    // Ajustar por criticidad del activo
    if (asset.criticality === "CRITICAL") {
      relevanceScore = Math.min(relevanceScore + 0.2, 1.0);
      reasons.push("Activo crítico");
    } else if (asset.criticality === "HIGH") {
      relevanceScore = Math.min(relevanceScore + 0.1, 1.0);
    }

    const relevant = relevanceScore >= this.relevanceThreshold;
    const riskLevel = this.determineRiskLevel(relevanceScore, ctiItem.severity);

    return {
      relevant,
      confidence: 0.7, // Confianza media en método heurístico
      relevanceScore: Math.round(relevanceScore * 100) / 100,
      reasons: reasons.length > 0 ? reasons : ["Evaluación basada en heurísticas"],
      riskLevel,
    };
  }

  /**
   * Determina si se debe generar una alerta
   * @param {Object} assessment - Evaluación de relevancia
   * @param {Object} ctiItem - Item CTI
   * @param {Object} asset - Activo
   * @returns {boolean} true si se debe generar alerta
   */
  shouldGenerateAlert(assessment, ctiItem, asset) {
    if (!assessment.relevant) {
      return false;
    }

    // Siempre generar para críticos con alta relevancia
    if (ctiItem.severity === "CRITICAL" && 
        assessment.relevanceScore >= this.criticalSeverityThreshold) {
      return true;
    }

    // Generar si relevancia supera umbral
    if (assessment.relevanceScore >= this.relevanceThreshold) {
      return true;
    }

    return false;
  }

  /**
   * Determina el tipo de alerta
   * @param {Object} assessment - Evaluación de relevancia
   * @param {Object} ctiItem - Item CTI
   * @returns {string} Tipo de alerta
   */
  determineAlertType(assessment, ctiItem) {
    if (ctiItem.severity === "CRITICAL" || assessment.riskLevel === "critical") {
      return "CRITICAL";
    }
    if (ctiItem.severity === "HIGH" || assessment.riskLevel === "high") {
      return "WARNING";
    }
    if (assessment.relevanceScore >= 0.7) {
      return "WARNING";
    }
    return "INFO";
  }

  /**
   * Genera descripción de alerta
   * @param {Object} ctiItem - Item CTI
   * @param {Object} asset - Activo
   * @param {Object} assessment - Evaluación
   * @returns {string} Descripción
   */
  generateAlertDescription(ctiItem, asset, assessment) {
    let description = `Vulnerabilidad detectada relacionada con el activo "${asset.name}".\n\n`;
    description += `${ctiItem.summary || ctiItem.title}\n\n`;
    
    if (ctiItem.cveIds && ctiItem.cveIds.length > 0) {
      description += `CVEs: ${ctiItem.cveIds.join(", ")}\n`;
    }

    if (assessment.reasons && assessment.reasons.length > 0) {
      description += `\nRazones de relevancia:\n${assessment.reasons.map(r => `- ${r}`).join("\n")}\n`;
    }

    description += `\nScore de relevancia: ${(assessment.relevanceScore * 100).toFixed(0)}%`;
    
    return description;
  }

  /**
   * Calcula la prioridad general del triage
   * @param {Array} evaluations - Evaluaciones por activo
   * @param {Object} ctiItem - Item CTI
   * @returns {string} Prioridad (high, medium, low)
   */
  calculateOverallPriority(evaluations, ctiItem) {
    const relevantCount = evaluations.filter(e => e.assessment.relevant).length;
    const totalCount = evaluations.length;

    if (ctiItem.severity === "CRITICAL" && relevantCount > 0) {
      return "high";
    }

    const relevanceRatio = totalCount > 0 ? relevantCount / totalCount : 0;

    if (relevanceRatio >= 0.5 || (ctiItem.severity === "HIGH" && relevantCount > 0)) {
      return "high";
    }

    if (relevanceRatio >= 0.2 || relevantCount > 0) {
      return "medium";
    }

    return "low";
  }

  /**
   * Determina nivel de riesgo
   * @param {number} relevanceScore - Score de relevancia
   * @param {string} severity - Severidad del CTI
   * @returns {string} Nivel de riesgo
   */
  determineRiskLevel(relevanceScore, severity) {
    if (severity === "CRITICAL" && relevanceScore >= 0.7) {
      return "critical";
    }
    if (severity === "HIGH" && relevanceScore >= 0.6) {
      return "high";
    }
    if (relevanceScore >= 0.7) {
      return "high";
    }
    if (relevanceScore >= 0.5) {
      return "medium";
    }
    if (relevanceScore >= 0.3) {
      return "low";
    }
    return "none";
  }

  /**
   * Valida la entrada
   * @param {Object} input - Entrada a validar
   * @returns {boolean} true si es válida
   */
  validateInput(input) {
    return super.validateInput(input) &&
           input.ctiItem &&
           input.organizationId &&
           typeof input.organizationId === "string";
  }
}

export default TriageAgent;
export { TriageAgent };

